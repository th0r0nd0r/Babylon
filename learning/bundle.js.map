{"version":3,"sources":["webpack:///webpack/bootstrap 516764ab6a96d4a1e4c4","webpack:///./babylon.js","webpack:///./Player.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA;;;;;;;;;;;AC7DA;;AAEA,qDAAqD;;AAErD,8CAA8C;;AAE9C;;AAEA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,aAAa;AAC9B;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,yD;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;;;AAGA;AACA,iBAAiB,sBAAsB;AACvC;;AAEA,uDAAuD,gBAAgB;AACvE;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,wGAAwG,yCAAyC;AACjJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA,KAAK;AACL;AACA;AACA,GAAG;AACH;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA,gEAAgE,mCAAmC;AACnG,6GAA6G,0BAA0B;;AAEvI;;;AAGA;;AAEA,+DAA+D,4BAA4B;AAC3F;AACA;AACA;AACA,4GAA4G,yCAAyC;;AAErJ;AACA;AACA,CAAC;;;AAGD;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,kCAAkC;AAClC;AACA,CAAC;;;AAGD,+CAA+C;AAC/C;AACA,CAAC,E;;;;;;ACzJD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,eAAe;AACf;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B,0BAA0B;AAC1B,0BAA0B;AAC1B,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA","file":"./bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 516764ab6a96d4a1e4c4","import './Player.js';\n\nvar canvas = document.getElementById(\"renderCanvas\"); // Get the canvas element \n\nvar engine = new BABYLON.Engine(canvas, true); // Generate the BABYLON 3D engine\n\nconst Cannon = new BABYLON.CannonJSPlugin;\n\nconst translatePositions = (positions, offsets) => {\n  console.log(positions.length);\n  let yIdx = 1;\n  let zIdx = 2;\n\n  const length = positions.length - 1;\n  for (let i = 0; i <= length; i++) {\n    if (i === zIdx) {\n      let z = positions[zIdx];\n      let y = positions[yIdx];\n\n      positions[zIdx] = y;\n      positions[yIdx] = z;\n\n      zIdx += 3;\n      yIdx += 3;\n    }\n\n\n  }\n\n  return positions;\n};\n\nfunction shootNet(offsets) {\n\n  if (!offsets) {\n    offsets = [0,0,0];\n  }\n\n  var subdivisions = 20;\n  var groundWidth = 8;\n  \n  var distanceBetweenPoints = groundWidth / subdivisions;\t\n  \n  var clothMat = new BABYLON.StandardMaterial(\"texture3\", scene);\n    clothMat.diffuseTexture = new BABYLON.Texture(\"http://i.imgur.com/2HklR1L.jpg\", scene);\n  clothMat.zOffset = -20;\n  clothMat.backFaceCulling = false;\n  \n  \n    // Our built-in 'ground' shape. Params: name, width, depth, subdivs, scene\n    var ground = BABYLON.Mesh.CreateGround(\"ground1\", groundWidth, groundWidth, subdivisions - 1, scene, true);\n    ground.material = clothMat;\n    // realGround.material = clothMat;\n  \n  \n  var positions = translatePositions(ground.getVerticesData(BABYLON.VertexBuffer.PositionKind), offsets);\n  ground.updateVerticesData(BABYLON.VertexBuffer.PositionKind, positions);\n  \n  \n  var spheres = [];\n  for (var i = 0; i < positions.length; i = i + 3) {\n    var v = BABYLON.Vector3.FromArray(positions, i);\n    \n    var s = BABYLON.MeshBuilder.CreateSphere(\"s\" + i, { diameter: 0.1 }, scene);\n    s.position.copyFrom(v);\n    spheres.push(s);\n  }\n  \n  function createJoint(imp1, imp2) {\n    var joint = new BABYLON.DistanceJoint({\n      maxDistance: distanceBetweenPoints\n    });\n    imp1.addJoint(imp2, joint);\n  }\n  \n  //create the impostors\n  spheres.forEach(function (point, idx) {\n    var mass = 15;\n    point.physicsImpostor = new BABYLON.PhysicsImpostor(point, BABYLON.PhysicsImpostor.SphereImpostor, { mass: mass, restitution: 0, radius: .1 }, scene);\n    point.physicsImpostor.setLinearVelocity( new BABYLON.Vector3(0,0,50));\n        if (idx >= subdivisions) {\n      createJoint(point.physicsImpostor, spheres[idx - subdivisions].physicsImpostor);\n      if (idx % subdivisions) {\n        createJoint(point.physicsImpostor, spheres[idx - 1].physicsImpostor);\n      }\n    }\n  });\n  \n  ground.registerBeforeRender(function () {\n    var positions = [];\n    spheres.forEach(function (s) {\n      positions.push(s.position.x, s.position.y, s.position.z);\n  \n    });\n    ground.updateVerticesData(BABYLON.VertexBuffer.PositionKind, positions);\n    ground.refreshBoundingInfo();\n  });\n}\n\nvar createScene = function () {\n\n  // This creates a basic Babylon Scene object (non-mesh)\n  var scene = new BABYLON.Scene(engine);\nscene.enablePhysics(new BABYLON.Vector3(0,-9.81,0), Cannon);\n\n  var camera = new BABYLON.ArcRotateCamera(\"Camera\", 3 * Math.PI / 2, Math.PI / 2, 30, BABYLON.Vector3.Zero(), scene);\n\ncamera.attachControl(canvas, true);\n\n  // This creates a light, aiming 0,1,0 - to the sky (non-mesh)\n  var light = new BABYLON.HemisphericLight(\"light1\", new BABYLON.Vector3(0, 1, 0), scene);\n\n  // Default intensity is 1. Let's dim the light a small amount\n  light.intensity = 0.7;\n\n  var realGround = BABYLON.MeshBuilder.CreateBox(\"realGround\", {height: .5, width: 400, depth: 400}, scene);\n  realGround.physicsImpostor = new BABYLON.PhysicsImpostor(realGround, BABYLON.PhysicsImpostor.BoxImpostor, { mass: 0, restitution: 1 }, scene);\n  \n  realGround.position.y = -30;\n\n\n  shootNet();\n\nvar bigSphere = BABYLON.MeshBuilder.CreateSphere(\"bigSphere\", { diameter: 1, segments: 16 }, scene);\nbigSphere.position.y = 1;\nbigSphere.position.x = 0;\nbigSphere.position.z = 8;\nbigSphere.physicsImpostor = new BABYLON.PhysicsImpostor(bigSphere, BABYLON.PhysicsImpostor.SphereImpostor, { mass: 50, restitution: 0, friction: 10 }, scene);\n\nbigSphere.registerBeforeRender ( () => {\n  // bigSphere.physicsImpostor.applyImpulse(new BABYLON.Vector3(0,0,0), bigSphere.getAbsolutePosition());\n});\n\n\nreturn scene;\n\n};\n\nvar scene = createScene();\n\nconsole.log(\"cloth method: \", shootNet);\n\nconst player = new Player(scene, shootNet);\n\n// scene.debugLayer.show();\n\nengine.runRenderLoop(function () { // Register a render loop to repeatedly render the scene\n        scene.render();\n});\n\n\nwindow.addEventListener(\"resize\", function () { // Watch for browser/canvas resize events\n        engine.resize();\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./babylon.js\n// module id = 0\n// module chunks = 0","/**\n * A player is represented by a box and a free camera.\n * @param scene\n * @param game\n * @param spawnPoint The spawning point of the player\n * @constructor\n */\nPlayer = function(scene, shoot, spawnPoint) {\n\n  if (!spawnPoint) {\n      spawnPoint = new BABYLON.Vector3(0,10,-50);\n  }\n\n  // The player spawnPoint\n  this.spawnPoint = spawnPoint;\n  // The game scene\n  this.scene = scene;\n\n  this.shoot = shoot;\n  // The game\n  // this.game = game;\n  // The player eyes height\n  this.height = 2;\n  // The player speed\n  this.speed = 40;\n  // The player inertia\n  this.inertia = 0.2;\n  // The player angular inertia\n  this.angularInertia = 0;\n  // The mouse sensibility (lower the better sensible)\n  this.angularSensibility = 1000;\n  // The player camera\n  this.camera = this._initCamera();\n  // The player must click on the canvas to activate control\n  this.controlEnabled = false;\n  // The player weapon\n  // this.weapon = new Weapon(game, this);\n  var _this = this;\n\n  var canvas = this.scene.getEngine().getRenderingCanvas();\n  // Event listener on click on the canvas\n  canvas.addEventListener(\"click\", function(evt) {\n      var width = _this.scene.getEngine().getRenderWidth();\n      var height = _this.scene.getEngine().getRenderHeight();\n\n      if (_this.controlEnabled) {\n          var pickInfo = _this.scene.pick(width/2, height/2, null, false, _this.camera);\n          _this.handleUserMouse(evt, pickInfo);\n      }\n  }, false);\n\n  // Event listener to go pointer lock\n  this._initPointerLock();\n\n  // The representation of player in the minimap\n  var s = BABYLON.Mesh.CreateSphere(\"player2\", 16, 4, this.scene);\n  s.position.y = 10;\n  s.registerBeforeRender(function() {\n      s.position.x = _this.camera.position.x;\n      s.position.z = _this.camera.position.z;\n  });\n\n  var red = new BABYLON.StandardMaterial(\"red\", this.scene);\n  red.diffuseColor = BABYLON.Color3.Red();\n  red.specularColor = BABYLON.Color3.Black();\n  s.material = red;\n  s.layerMask = 1;\n\n  // Set the active camera for the minimap\n  this.scene.activeCameras.push(this.camera);\n  this.scene.activeCamera = this.camera;\n\n\n};\n\nPlayer.prototype = {\n\n  _initPointerLock : function() {\n      var _this = this;\n      // Request pointer lock\n      var canvas = this.scene.getEngine().getRenderingCanvas();\n      canvas.addEventListener(\"click\", function(evt) {\n          canvas.requestPointerLock = canvas.requestPointerLock || canvas.msRequestPointerLock || canvas.mozRequestPointerLock || canvas.webkitRequestPointerLock;\n          if (canvas.requestPointerLock) {\n              canvas.requestPointerLock();\n          }\n      }, false);\n\n      // Event listener when the pointerlock is updated.\n      var pointerlockchange = function (event) {\n          _this.controlEnabled = (document.mozPointerLockElement === canvas || document.webkitPointerLockElement === canvas || document.msPointerLockElement === canvas || document.pointerLockElement === canvas);\n          if (!_this.controlEnabled) {\n              _this.camera.detachControl(canvas);\n          } else {\n              _this.camera.attachControl(canvas);\n          }\n      };\n      document.addEventListener(\"pointerlockchange\", pointerlockchange, false);\n      document.addEventListener(\"mspointerlockchange\", pointerlockchange, false);\n      document.addEventListener(\"mozpointerlockchange\", pointerlockchange, false);\n      document.addEventListener(\"webkitpointerlockchange\", pointerlockchange, false);\n  },\n\n  /**\n   * Init the player camera\n   * @returns {BABYLON.FreeCamera}\n   * @private\n   */\n  _initCamera : function() {\n\n      var cam = new BABYLON.FreeCamera(\"camera\", this.spawnPoint, this.scene);\n      cam.attachControl(this.scene.getEngine().getRenderingCanvas());\n      cam.ellipsoid = new BABYLON.Vector3(2, this.height, 2);\n      cam.checkCollisions = false;\n      cam.applyGravity = true;\n      // ZQSD\n      cam.keysUp.push(87); // W\n      cam.keysDown = [83]; // S\n      cam.keysLeft = [65]; // A\n      cam.keysRight = [68]; // D\n      cam.speed = this.speed;\n      cam.inertia = this.inertia;\n      cam.angularInertia = this.angularInertia;\n      cam.angularSensibility = this.angularSensibility;\n      cam.layerMask = 2;\n\n      return cam;\n  },\n\n  /**\n   * Handle the user input on keyboard\n   * @param keycode\n   */\n  handleUserKeyboard : function(keycode) {\n      switch (keycode) {\n\n      }\n  },\n\n  /**\n   * Handle the user input on mouse.\n   * click = shoot\n   * @param evt\n   * @param pickInfo The pick data retrieved when the click has been done\n   */\n  handleUserMouse : function(evt, pickInfo) {\n    console.log(\"pickInfo: \", pickInfo);\n    console.log(\"cameraPos: \", this.camera.position);\n    const offsets = [this.camera.position.x, this.camera.position.y, this.camera.position.z];\n\n      this.shoot(offsets);\n  }\n\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./Player.js\n// module id = 1\n// module chunks = 0"],"sourceRoot":""}